#rewriting my code to try to cut it down a little :)
library(imager)
#"C:/Users/slate/Desktop/Eueretagrotis_sigmoides_629.JPG"<--high contrast moth
#"C:/Users/slate/Desktop/Iridopsis_ephyraria_73 - Copy.JPG"<--low contrast moth
#"C:/Users/slate/Desktop/Leuconycta_dipheroides_628.JPG"<--Noctuidea example
#"C:/Users/slate/Desktop/Acrobasis_indiginella_727-2.jpg"<--tiny guy
#"C:/Users/slate/Desktop/New folder/Scopula_limboundata_79.JPG"<--objects in image
mothp <-load.image("C:/Users/slate/Desktop/Leuconycta_dipheroides_628.JPG")
moths <- imresize(mothp,scale=0.5)

plot(moths,main="The original moth") #<-Now we can see it :)

#Step 1: from Canny edge detection (turn to greyscale)
#https://justin-liang.com/tutorials/canny/ 
gmoth <- grayscale(moths)
plot(gmoth, main="Greyscale of Moth")

#If you get an error on this stage try looking at the dimensions with
#dim(moths) <--it could be that if you use a photo editor it will change the formatting 
#so there is only 1 meaning there must have been something that mucked it up
#(x,y,c<--colorchannel,z<--frames)

#Step 2 Gaussian Blur <--I found a way to set in imager :)
#so it very varied for me if the moth image was small
#bmoth<-isoblur(gmoth,5,neumann = TRUE, gaussian = TRUE, na.rm = TRUE)

#calling for the x and y from this x,y,c<--colorchannel,z<--frames
Imagex<-dim(moths)[1]
Imagey<-dim(moths)[2]
#print(Imagex)
#print (ImageY)<--quick cutesy little test
#this basically will look @the height of pixels 
#Imagex*Imagey<--total pixels
#I don't really want the total area, I want more like the typicaly side length if it was a square
#...if that makes sense...thats y I square root it
blurcalc<-sqrt(Imagex*Imagey)*0.02 #<-- the higher the number the more blur
print(blurcalc)
bmoth<-isoblur(gmoth,blurcalc,neumann = TRUE, gaussian = TRUE, na.rm = TRUE)
plot(bmoth, main="Moth with Gaussian Blur")
#so IDEALLY this should change with the pixel number

#step 4 Uncanny
#Gradient magnitude did not work that well, it is not worth further exploring 
Uncanny1 <- cannyEdges(bmoth, sigma=blurcalc)
#I tried the blur calc with it and it works pretty good
plot(Uncanny1, main="CannyEdges normal")

#-----I should find a way to expand and shrink the pixels like in my 1st program!!!-----------------

#Step 5 smush it into a dataset!
# I found out for fnn to work I need to make it into a numeric matrix
#cause right now it is just a bunch of true and false values
coords <- which(Uncanny1, arr.ind = TRUE) #looks for true values
wing_points2 <- data.frame(
  yy2=coords[,1], #this will be my y corrd/row
  xx2=coords[,2] #this will be my x coord/colum 
  #they are flipped<--tested it with a graph
)
#str(coords) #oh it has false and true still in it

#step 6 connect with FNN
library(FNN) #Fast Nearest Neighbor Search

#I want to essentially take a point and remove it from the dataset
unvisited_point<-coords#<--I want to start off with all the info in the matrix being marked as unvisited
path<-unvisited_point[1,,drop=FALSE]#<--starting with the first point off the list!

while(nrow(unvisited_point)>0){ #<--while there are still points in unvisited
  mostrecentpt<-(tail(path,1))#<stores the last point, and 1 just makes it a single object:)
  
  Fnnlib<- get.knnx(data=unvisited_point,query=mostrecentpt,k=1, algorithm = "kd_tree")
                                          #k should be less than sample size!
  #https://www.rdocumentation.org/packages/FNN/versions/1.1.4.1
  #I may try out diffrent algorithms...DO NOT TRY COVER TREE IT CRASHED SO BADDD!!!
  # get.knnx(data, query, k=10, algorithm=c("kd_tree", "cover_tree", "CR", "brute"))
  
  nearestpoint <- Fnnlib$nn.index[1]
  test<-Fnnlib$nn.dist[1]
  
  #lets put it all together :)
  path<-rbind(path,unvisited_point[nearestpoint,,drop=FALSE])
  #bind_rows does not work for matrices apparently
  unvisited_point<-unvisited_point[-nearestpoint,,drop=FALSE]
  #head(unvisited)#<just to make sure its good
}
#visualize it
plot(path)

#lets make it into a polygon/connect da lines (this will help me work with smoothr)
#-----I NEED A FIND A WAY TO LIMIT THE JUMPS!!!--------------------------------------------
library(sf) #I think I want to convert to polygon...
closedatpath<- rbind(path, path[1,])#needs to be all closed
ggplot(closedatpath, aes(x=closedatpath[,1],y=closedatpath[,2]))+
  geom_polygon(fill="brown")+
  ggtitle("Awsome super cool moth fill")

#step 7 now some work with smoothR
#essentially this should help with removing islands and simplifying the overall shape
#https://github.com/mstrimas/smoothr



#step 8 size conversion
##coords_cm <- coordss * 0.0264583333#<-this is the conversion number of the cm to pixel
#If I find this to be inaccurate we will change it back to what it was originally
#(which was the color scale)
##moth_width_cm <- max(coordss_cm[,"x"]) - min(coordss_cm[,"x"])
##moth_height_cm <- max(coordss_cm[,"y"]) - min(coordss_cm[,"y"])


##plot (coordss,main = sprintf("Moth width: %.2f cm\nMoth height: %.2f cm\n", 
##                             moth_width_cm, moth_height_cm))#<suprisingly helpful to visualize

